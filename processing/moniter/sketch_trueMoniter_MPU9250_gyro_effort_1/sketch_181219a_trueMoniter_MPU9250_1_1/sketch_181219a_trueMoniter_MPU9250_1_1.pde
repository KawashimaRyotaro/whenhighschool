import processing.serial.*;

float gx, gy, gz, ax, ay, az, mx, my, mz;

////////////////////////////////////////波形保存////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[][] gx1,    gy1,    gz1;

///////////////////////////////////////1サイクルの合計//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[]   sgx_1,  sgy_1,  sgz_1;

////////////////////////////////////////////1サイクルの平均/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[]   avgx_1, avgy_1, avgz_1;

/////////////////////////////////////////分散///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[]   gxs_1,  gys_1,  gzs_1;

//////////////////////////////////////////平均波////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[]   avgx1,  avgy1,  avgz1;
float[]   avgx2,  avgy2,  avgz2;

////////////////////////////////////////ドリフト////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[]   pdgx,   pdgy,   pdgz;
float     sdgx=0, sdgy=0, sdgz=0;
float     avdgx,  avdgy,  avdgz;
float     dgxs=0, dgys=0, dgzs=0;
float     dgx=0,  dgy=0,  dgz=0;
float     s1=0,   s2=0,   s3=0,  s4=0,  s5=0,  s6=0,  s7=0,  s8=0,  s9=0;
float[]   d1,     d2,     d3;

/////////////////////////////////////////分散逆数・ゲイン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float[]   a1,     a2,     a3;
float     S1=0,   S2=0,   S3=0,   S4=0,   S5=0,   S6=0,   S7=0,   S8=0,   S9=0,   K=1,   k1=5, k2=5;

/////////////////////////////////////////////その他/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float     x=0,    y=0,    z=0;
float     x1,     y1,     z1;
int       num1=0, num2=0, num3=0, n1=5, n2=100, a=0;
int       serialTimer;
Serial myPort;














void setup() {
  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                 /*配列宣言*/
//g値

  gx1=new float[n1+1][n2];     
  gy1=new float[n1+1][n2];
  gz1=new float[n1+1][n2];  
  
//sum値

  sgx_1=new float[n1+1];
  sgy_1=new float[n1+1];
  sgz_1=new float[n1+1];
  for(int i=0; i<=n1; i++){
    sgx_1[i]=0;
    sgy_1[i]=0;
    sgz_1[i]=0;
  }

//av値

  avgx_1=new float[n1+1];
  avgy_1=new float[n1+1];
  avgz_1=new float[n1+1];
  
//s値
  
  gxs_1=new float[n1+1];
  gys_1=new float[n1+1];
  gzs_1=new float[n1+1];
  

//av波

  avgx1=new float[n2];  
  avgy1=new float[n2];
  avgz1=new float[n2];    
  avgx2=new float[n2];  
  avgy2=new float[n2];
  avgz2=new float[n2];   
  
//d値

  pdgx=new float[n1+1];
  pdgy=new float[n1+1];
  pdgz=new float[n1+1]; 
  d1=new float[n1+1];
  d2=new float[n1+1];
  d3=new float[n1+1];
  
//分散ゲイン
  
  a1=new float[n1];
  a2=new float[n1];
  a3=new float[n1];
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                           /*画面生成ステップ*/
  
  size(1000, 1000);
  myPort = new Serial(this, "COM4", 57600);
}

void draw() {
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                          /*シリアル通信ステップ*/

    if (millis()-serialTimer > 50) {
    serialTimer = millis();
    byte[] inBuf = new byte[20];
    println(myPort.available());
    if (myPort.available() == 20) {
      myPort.readBytes(inBuf);
      if (inBuf[0]=='s'&&inBuf[19]=='e') {
        gx = (inBuf[1]<<8)+(inBuf[2]&0xff);
        gy = (inBuf[3]<<8)+(inBuf[4]&0xff);
        gz = (inBuf[5]<<8)+(inBuf[6]&0xff);
        ax = (inBuf[7]<<8)+(inBuf[8]&0xff);
        ay = (inBuf[9]<<8)+(inBuf[10]&0xff);
        az = (inBuf[11]<<8)+(inBuf[12]&0xff);
        mx = (inBuf[13]<<8)+(inBuf[14]&0xff);
        my = (inBuf[15]<<8)+(inBuf[16]&0xff);
        mz = (inBuf[17]<<8)+(inBuf[18]&0xff);
        gx/=10000.0;
        gy/=10000.0;
        gz/=10000.0;
        ax/=100.0;
        ay/=100.0;
        az/=100.0;
        mx/=100.0;
        my/=100.0;
        mz/=100.0;
        ax-=2;
        ay-=1;
        az-=1;
      } else {
        while (myPort.available()>0)myPort.read();
        println("missMatch");
      }
    } else if (myPort.available() > 14) {
      while (myPort.available()>0)myPort.read();
      println("overflowe");
    }

    byte[] outBuf = new byte[1];
    outBuf[0]     = 's';
    myPort.write(outBuf);
  }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                  /*a補正ステップ*/
  
  if(ax>=100){
    
    ax=100;
  }else if(ax<=-100){
    
    ax=-100;
  }else if(ay>=100){
    
    ay=100;
  }else if(ay<=-100){
    
    ay=-100;
  }else if(az>=100){
    
    az=100;
  }else if(az<=-100){
    
    az=-100;
  
  }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                /*g補正ステップ*/
                                                                                
//第一フェーズ

if(num2<n1 && num3<n2){
   
//波の保存
    
  gx1[num2][num3]=gx;
  gy1[num2][num3]=gy;
  gz1[num2][num3]=gz;

//波の加算

  sgx_1[num2]+=gx;
  sgy_1[num2]+=gy;
  sgz_1[num2]+=gz;
  
}
if(num2<n1 && num3==n2){

//波の平均
    
  avgx_1[num2]=sgx_1[num2]/n2;
  avgy_1[num2]=sgy_1[num2]/n2;
  avgz_1[num2]=sgz_1[num2]/n2;
  
//波の分散（信頼度）算出

  for(int i=0; i<n2; i++){
 
    gxs_1[num2]+=sq(gx1[num2][i]-avgx_1[num2]);
    gys_1[num2]+=sq(gy1[num2][i]-avgy_1[num2]);
    gzs_1[num2]+=sq(gz1[num2][i]-avgz_1[num2]);
    
  }
  
  gxs_1[num2]=sqrt(gxs_1[num2]/num3);
  gys_1[num2]=sqrt(gys_1[num2]/num3);
  gzs_1[num2]=sqrt(gys_1[num2]/num3);
    
  sgx_1[num2]=0;
  sgy_1[num2]=0;
  sgz_1[num2]=0;                     //合計リセット
  
  num3=0;                            //波リセット
  num2++;                            //波切り替え
    
  if(num2<n1){
    gx1[num2][num3]=gx;
    gy1[num2][num3]=gy;
    gz1[num2][num3]=gz;
   
    sgx_1[num2]+=gx;
    sgy_1[num2]+=gy;
    sgz_1[num2]+=gz;
  }
  
//第二フェーズ

  if(num2==n1){
  
//必要データ取得
  
    for(int j=0; j<n1; j++){
      a1[j]=1/gxs_1[j];
      a2[j]=1/gys_1[j];
      a3[j]=1/gzs_1[j];
      S1+=a1[j];
      S2+=a2[j];
      S3+=a3[j];
    }

//平均波記憶

    for(int i=0; i<n2; i++){
      for(int j=0; j<n1; j++){
        avgx1[i]+=gx1[j][i]*a1[j];
        avgy1[i]+=gy1[j][i]*a2[j];
        avgz1[i]+=gz1[j][i]*a3[j];
      }
      avgx1[i]/=S1;
      avgy1[i]/=S2;
      avgz1[i]/=S3;
    
    }
  
//ドリフト平均算出
  
    for(int i=0; i<n1; i++){
    
      sdgx+=avgx_1[i];
      sdgy+=avgy_1[i];
      sdgz+=avgz_1[i];
    }
  
    avdgx=sdgx/n1;
    avdgy=sdgy/n1;
    avdgz=sdgz/n1;
  
    for(int i=0; i<n1; i++){
  
      pdgx[i]=avgx_1[i]-avdgx;
      pdgy[i]=avgy_1[i]-avdgy;
      pdgz[i]=avgz_1[i]-avdgz;
    
      d1[i]=1/pdgx[i];
      d2[i]=1/pdgy[i];
      d3[i]=1/pdgz[i];
    
      s1+=d1[i];
      s2+=d2[i];
      s3+=d3[i];
    }
  
    for(int i=0; i<n1; i++){
    
      dgx+=avgx_1[i]*d1[i];
      dgy+=avgy_1[i]*d2[i];
      dgz+=avgz_1[i]*d3[i];
    }
  
    dgx/=s1;
    dgy/=s2;
    dgz/=s3;
  
    sdgx=0;
    sdgy=0;
    sdgz=0;
  
    num3=0;
  }
}
  
//第三フェーズ
//平均波、平均ドリフトで引く

if(num3<n2&&num2==n1){
  gx-=avgx1[num3]+dgx-0.0;
  gy-=avgy1[num3]+dgy+0.0;
  gz-=avgz1[num3]+dgz-0.00;
    
  gx1[n1][num3]=gx;
  gy1[n1][num3]=gy;
  gz1[n1][num3]=gz;
    
  sgx_1[n1]+=gx;
  sgy_1[n1]+=gy;
  sgz_1[n1]+=gz;
  
  num1++;           //タイム加算
}
    
//第四フェーズ

if(num2==n1 && num3==n2){
    
//平均波更新
    
  for(int j=0; j<n1; j++){
    a1[j]=1/gxs_1[j];
    a2[j]=1/gys_1[j];
    a3[j]=1/gzs_1[j];
    S1+=a1[j];
    S2+=a2[j];
    S3+=a3[j];
  }
  
  S4=k1*S1;
  S5=k1*S2;
  S6=k1*S3;
    
  S7=S1+S4;
  S8=S2+S5;
  S9=S3+S6;
    
  for(int i=0; i<n2; i++){
    avgx1[i]+=avgx1[i]*S4;
    avgy1[i]+=avgy1[i]*S5;
    avgz1[i]+=avgz1[i]*S6;
    for(int j=0; j<n1; j++){
      avgx1[i]+=gx1[j][i]*a1[j];
      avgy1[i]+=gy1[j][i]*a2[j];
      avgz1[i]+=gz1[j][i]*a3[j];
    }
    avgx1[i]/=S7;
    avgy1[i]/=S8;
    avgz1[i]/=S9;
  }
    
//平均算出

  avgx_1[n1]=sgx_1[n1]/num3;
  avgy_1[n1]=sgy_1[n1]/num3;
  avgz_1[n1]=sgz_1[n1]/num3;
  
  sgx_1[n1]=0;
  sgy_1[n1]=0;
  sgz_1[n1]=0;

//ドリフト算出

  for(int i=0; i<=n1; i++){
    
    sdgx+=avgx_1[i];
    sdgy+=avgy_1[i];
    sdgz+=avgz_1[i];
  }
  
  avdgx=sdgx/n1+1;
  avdgy=sdgy/n1+1;
  avdgz=sdgz/n1+1;
  
  for(int i=0; i<=n1; i++){
  
    pdgx[i]=avgx_1[i]-avdgx;
    pdgy[i]=avgy_1[i]-avdgy;
    pdgz[i]=avgz_1[i]-avdgz;
    
    d1[i]=1/pdgx[i];
    d2[i]=1/pdgy[i];
    d3[i]=1/pdgz[i];
    
    s1+=d1[i];
    s2+=d2[i];
    s3+=d3[i];
  }
  
  s4=k2*s1;
  s5=k2*s2;
  s6=k2*s3;
  
  s7=s1+s4;
  s8=s2+s5;
  s9=s3+s6;
  
  dgx+=dgx*s4;
  dgy+=dgy*s5;
  dgz+=dgz*s6;
  
  for(int i=0; i<=n1; i++){
    
    dgx+=avgx_1[i]*d1[i];
    dgy+=avgy_1[i]*d2[i];
    dgz+=avgz_1[i]*d3[i];
  }
  
  dgx/=s7;
  dgy/=s8;
  dgz/=s9;
  
  sdgx=0;
  sdgy=0;
  sdgz=0;
  
  
//分散算出
  
  for(int i=0; i<n2; i++){
    gxs_1[n1]+=sq(gx1[n1][i]);
    gys_1[n1]+=sq(gy1[n1][i]);
    gzs_1[n1]+=sq(gy1[n1][i]);
  }
   
  gxs_1[n1]=sqrt(gxs_1[n1]/num3);
  gys_1[n1]=sqrt(gys_1[n1]/num3);
  gzs_1[n1]=sqrt(gzs_1[n1]/num3);
    
//記憶フェーズ
//g値保存

  for(int i=0; i<n2; i++){
    for(int j=0; j<n1; j++){
      gx1[j][i]=gx1[j+1][i];
      gy1[j][i]=gy1[j+1][i];
      gz1[j][i]=gz1[j+1][i];
    }
  }

    
//平均、分散保存
  for(int i=0; i<n1; i++){
    gxs_1[i]=gxs_1[i+1];
    gys_1[i]=gys_1[i+1];
    gzs_1[i]=gzs_1[i+1];
    avgx_1[i]=avgx_1[i+1];
    avgy_1[i]=avgy_1[i+1];
    avgz_1[i]=avgz_1[i+1];
  }
  num1++;               //安定タイム加算
  num3=0;               //波リセット

  
}

//角度積算

  if(num1>=1000){
    x+=gx;
    y+=gy;
    z+=gz;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  }
  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                             /*モニターステップ*/
  
  background(0);
  fill(240);
  textSize(24);
  plint_tex();
  text(nf(gx*100, 0, 2), 50, 50);
  text(nf(gy*100, 0, 2), 50, 80);
  text(nf(gz*100, 0, 2), 50, 110);
  text(nf(ax, 0, 2), 50, 140);
  text(nf(ay, 0, 2), 50, 170);
  text(nf(az, 0, 2), 50, 200);
  text(nf(mx, 0, 2), 50, 230);
  text(nf(my, 0, 2), 50, 260);
  text(nf(mz, 0, 2), 50, 290);
  text(nf(x, 0, 2), 50, 320);
  text(nf(y, 0, 2), 50, 350);
  text(nf(z, 0, 2), 50, 380);
  text(nf( sgx_1[num2], 0, 2), 50, 410);
  text(nf( num3, 0, 2), 50, 440);
  text(nf( num2, 0, 2), 50, 470);
  if(num2>0){
  text(nf( avgx_1[5], 0, 2), 50, 500);
  text(nf(  gxs_1[5], 0, 2), 50, 590);
  }
  text(nf( a, 0, 2), 50, 530);
  text(nf( dgx*100, 0, 2), 50, 560);
  num3++;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                               /*表題ステップ*/

void plint_tex(){
  text("gx:", 10, 50);
  text("gy:", 10, 80);
  text("gz:", 10, 110);
  text("ax:", 10, 140);
  text("ay:", 10, 170);
  text("az:", 10, 200);
  text("mx:", 10, 230);
  text("my:", 10, 260);
  text("mz:", 10, 290);
  text("x:", 10, 320);
  text("y:", 10, 350);
  text("z:", 10, 380);
  text("x1:", 10, 410);
  text("y1:", 10, 440);
  text("z1:", 10, 470);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
